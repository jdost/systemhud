#!/usr/bin/env python3

"""
TODO:
- fix the icon sizing issue, the bluetooth glyph is different height between
  the three states, probably need different fonts?
"""

import asyncio
import signal
from time import sleep
from typing import Dict

from systemhud import register_signal, run, update_stream
from systemhud.lib import bluetooth
from systemhud.ui import rofi
from systemhud.ui.icons import set_icon
from systemhud.ui.notifications import Notification

ICONS = {"on": "", "off": "%{F#999}%{F-}", "connected": "%{F#5AF}%{F-}"}
notifications: Dict[str, Notification] = {}
controller_notification = Notification(
    "bluetooth", icon="bluetooth", timeout=1500, transient=True
)


async def menu_popup(*_) -> None:
    devices = await bluetooth.get_devices()
    status = bool(await bluetooth.get_status())
    _CONTROLLER_KEY = "__CONTROLLER__"
    entries = [
        rofi.Entry(
            "Controller", active=status, icon="bluetooth", value=_CONTROLLER_KEY
        )
    ]
    entries += [
        rofi.Entry(
            dev.name, active=dev.connected, icon=dev.icon, value=dev.device_id
        )
        for dev in devices.values()
    ]

    selection = await rofi.rofi(entries, theme="icons")
    if not selection:
        return
    if selection.value == _CONTROLLER_KEY:
        if status:
            await asyncio.gather(
                *[d.toggle() for d in devices.values() if d.connected]
            )
        await bluetooth.toggle()
    else:
        # Turn on the controller if it is off, otherwise we *know* the toggle
        # will fail
        if not status:
            await bluetooth.toggle()
        await devices[selection.value].toggle()


async def main() -> None:
    register_signal(signal.SIGUSR1, menu_popup)

    status = bool(await bluetooth.get_status())
    devices: Dict[str, bluetooth.Device] = (
        await bluetooth.get_devices() if status else {}
    )

    if not status:
        set_icon(ICONS["off"])
    elif any([d.connected for d in devices.values()]):
        set_icon(ICONS["connected"])
    else:
        set_icon(ICONS["on"])

    async for line in update_stream("bluetoothctl"):
        status, dev_type, dev_id, meta = bluetooth.parse_bluetoothctl_logline(
            line
        )

        if dev_type is bluetooth.BluetoothType.CONTROLLER:
            try:
                k, v = meta.split(":", 1)
            except ValueError:
                continue

            if k.strip() == "Powered":
                on = v.strip() == "yes"
                controller_notification(
                    title="Bluetooth Controller",
                    body=("Powered On" if on else "Powered Off"),
                    image=("bluetooth-active" if on else "bluetooth-disabled"),
                )
                set_icon(ICONS["on" if on else "off"])
                if on:
                    devices = await bluetooth.get_devices()
        elif dev_type is bluetooth.BluetoothType.DEVICE:
            # This is not a paired devices, TODO support handling pairing a
            # device
            if dev_id not in devices:
                continue

            if status is bluetooth.BluetoothCtlStatus.CHANGED:
                if await devices[dev_id].update():
                    device = devices[dev_id]
                    if device.connected:
                        set_icon(ICONS["connected"])
                    elif not any([d.connected for d in devices.values()]):
                        set_icon(ICONS["on"])

                    n = notifications.setdefault(
                        device.device_id,
                        Notification(
                            "bluetooth", icon="bluetooth", timeout=1500
                        ),
                    )
                    n.transient = not device.connected
                    n(
                        title=device.name,
                        body="Connected"
                        if device.connected
                        else "Disconnected",
                        image=device.icon,
                    )


if __name__ == "__main__":
    run(main)
